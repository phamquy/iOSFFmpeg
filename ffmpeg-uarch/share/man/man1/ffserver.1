.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "FFSERVER 1"
.TH FFSERVER 1 "2012-10-05" " " " "
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ffserver \- ffserver video server
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
ffserver [options]
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ffserver is a streaming server for both audio and video. It supports
.PP
several live feeds, streaming from files and time shifting on live feeds
(you can seek to positions in the past on each live feed, provided you
specify a big enough feed storage in ffserver.conf).
.PP
ffserver runs in daemon mode by default; that is, it puts itself in
the background and detaches from its \s-1TTY\s0, unless it is launched in
debug mode or a NoDaemon option is specified in the configuration
file.
.PP
This documentation covers only the streaming aspects of ffserver /
ffmpeg. All questions about parameters for ffmpeg, codec questions,
etc. are not covered here. Read \fIffmpeg.html\fR for more
information.
.SS "How does it work?"
.IX Subsection "How does it work?"
ffserver receives prerecorded files or \s-1FFM\s0 streams from some ffmpeg
instance as input, then streams them over \s-1RTP/RTSP/HTTP\s0.
.PP
An ffserver instance will listen on some port as specified in the
configuration file. You can launch one or more instances of ffmpeg and
send one or more \s-1FFM\s0 streams to the port where ffserver is expecting
to receive them. Alternately, you can make ffserver launch such ffmpeg
instances at startup.
.PP
Input streams are called feeds, and each one is specified by a <Feed>
section in the configuration file.
.PP
For each feed you can have different output streams in various
formats, each one specified by a <Stream> section in the configuration
file.
.SS "Status stream"
.IX Subsection "Status stream"
ffserver supports an \s-1HTTP\s0 interface which exposes the current status
of the server.
.PP
Simply point your browser to the address of the special status stream
specified in the configuration file.
.PP
For example if you have:
.PP
.Vb 2
\&        <Stream status.html>
\&        Format status
\&        
\&        # Only allow local people to get the status
\&        ACL allow localhost
\&        ACL allow 192.168.0.0 192.168.255.255
\&        </Stream>
.Ve
.PP
then the server will post a page with the status information when
the special stream \fIstatus.html\fR is requested.
.SS "What can this do?"
.IX Subsection "What can this do?"
When properly configured and running, you can capture video and audio in real
time from a suitable capture card, and stream it out over the Internet to
either Windows Media Player or RealAudio player (with some restrictions).
.PP
It can also stream from files, though that is currently broken. Very often, a
web server can be used to serve up the files just as well.
.PP
It can stream prerecorded video from .ffm files, though it is somewhat tricky
to make it work correctly.
.SS "What do I need?"
.IX Subsection "What do I need?"
I use Linux on a 900 MHz Duron with a cheapo Bt848 based \s-1TV\s0 capture card. I'm
using stock Linux 2.4.17 with the stock drivers. [Actually that isn't true,
I needed some special drivers for my motherboard-based sound card.]
.PP
I understand that FreeBSD systems work just fine as well.
.SS "How do I make it work?"
.IX Subsection "How do I make it work?"
First, build the kit. It *really* helps to have installed \s-1LAME\s0 first. Then when
you run the ffserver ./configure, make sure that you have the
\&\f(CW\*(C`\-\-enable\-libmp3lame\*(C'\fR flag turned on.
.PP
\&\s-1LAME\s0 is important as it allows for streaming audio to Windows Media Player.
Don't ask why the other audio types do not work.
.PP
As a simple test, just run the following two command lines where \s-1INPUTFILE\s0
is some file which you can decode with ffmpeg:
.PP
.Vb 2
\&        ffserver \-f doc/ffserver.conf &
\&        ffmpeg \-i INPUTFILE http://localhost:8090/feed1.ffm
.Ve
.PP
At this point you should be able to go to your Windows machine and fire up
Windows Media Player (\s-1WMP\s0). Go to Open \s-1URL\s0 and enter
.PP
.Vb 1
\&            http://<linuxbox>:8090/test.asf
.Ve
.PP
You should (after a short delay) see video and hear audio.
.PP
\&\s-1WARNING:\s0 trying to stream test1.mpg doesn't work with \s-1WMP\s0 as it tries to
transfer the entire file before starting to play.
The same is true of \s-1AVI\s0 files.
.SS "What happens next?"
.IX Subsection "What happens next?"
You should edit the ffserver.conf file to suit your needs (in terms of
frame rates etc). Then install ffserver and ffmpeg, write a script to start
them up, and off you go.
.SS "Troubleshooting"
.IX Subsection "Troubleshooting"
\fII don't hear any audio, but video is fine.\fR
.IX Subsection "I don't hear any audio, but video is fine."
.PP
Maybe you didn't install \s-1LAME\s0, or got your ./configure statement wrong. Check
the ffmpeg output to see if a line referring to \s-1MP3\s0 is present. If not, then
your configuration was incorrect. If it is, then maybe your wiring is not
set up correctly. Maybe the sound card is not getting data from the right
input source. Maybe you have a really awful audio interface (like I do)
that only captures in stereo and also requires that one channel be flipped.
If you are one of these people, then export 'AUDIO_FLIP_LEFT=1' before
starting ffmpeg.
.PP
\fIThe audio and video lose sync after a while.\fR
.IX Subsection "The audio and video lose sync after a while."
.PP
Yes, they do.
.PP
\fIAfter a long while, the video update rate goes way down in \s-1WMP\s0.\fR
.IX Subsection "After a long while, the video update rate goes way down in WMP."
.PP
Yes, it does. Who knows why?
.PP
\fI\s-1WMP\s0 6.4 behaves differently to \s-1WMP\s0 7.\fR
.IX Subsection "WMP 6.4 behaves differently to WMP 7."
.PP
Yes, it does. Any thoughts on this would be gratefully received. These
differences extend to embedding \s-1WMP\s0 into a web page. [There are two
object IDs that you can use: The old one, which does not play well, and
the new one, which does (both tested on the same system). However,
I suspect that the new one is not available unless you have installed \s-1WMP\s0 7].
.SS "What else can it do?"
.IX Subsection "What else can it do?"
You can replay video from .ffm files that was recorded earlier.
However, there are a number of caveats, including the fact that the
ffserver parameters must match the original parameters used to record the
file. If they do not, then ffserver deletes the file before recording into it.
(Now that I write this, it seems broken).
.PP
You can fiddle with many of the codec choices and encoding parameters, and
there are a bunch more parameters that you cannot control. Post a message
to the mailing list if there are some 'must have' parameters. Look in
ffserver.conf for a list of the currently available controls.
.PP
It will automatically generate the \s-1ASX\s0 or \s-1RAM\s0 files that are often used
in browsers. These files are actually redirections to the underlying \s-1ASF\s0
or \s-1RM\s0 file. The reason for this is that the browser often fetches the
entire file before starting up the external viewer. The redirection files
are very small and can be transferred quickly. [The stream itself is
often 'infinite' and thus the browser tries to download it and never
finishes.]
.SS "Tips"
.IX Subsection "Tips"
* When you connect to a live stream, most players (\s-1WMP\s0, \s-1RA\s0, etc) want to
buffer a certain number of seconds of material so that they can display the
signal continuously. However, ffserver (by default) starts sending data
in realtime. This means that there is a pause of a few seconds while the
buffering is being done by the player. The good news is that this can be
cured by adding a '?buffer=5' to the end of the \s-1URL\s0. This means that the
stream should start 5 seconds in the past \*(-- and so the first 5 seconds
of the stream are sent as fast as the network will allow. It will then
slow down to real time. This noticeably improves the startup experience.
.PP
You can also add a 'Preroll 15' statement into the ffserver.conf that will
add the 15 second prebuffering on all requests that do not otherwise
specify a time. In addition, ffserver will skip frames until a key_frame
is found. This further reduces the startup delay by not transferring data
that will be discarded.
.PP
* You may want to adjust the MaxBandwidth in the ffserver.conf to limit
the amount of bandwidth consumed by live streams.
.SS "Why does the ?buffer / Preroll stop working after a time?"
.IX Subsection "Why does the ?buffer / Preroll stop working after a time?"
It turns out that (on my machine at least) the number of frames successfully
grabbed is marginally less than the number that ought to be grabbed. This
means that the timestamp in the encoded data stream gets behind realtime.
This means that if you say 'Preroll 10', then when the stream gets 10
or more seconds behind, there is no Preroll left.
.PP
Fixing this requires a change in the internals of how timestamps are
handled.
.ie n .SS "Does the ""?date="" stuff work."
.el .SS "Does the \f(CW?date=\fP stuff work."
.IX Subsection "Does the ?date= stuff work."
Yes (subject to the limitation outlined above). Also note that whenever you
start ffserver, it deletes the ffm file (if any parameters have changed),
thus wiping out what you had recorded before.
.PP
The format of the \f(CW\*(C`?date=xxxxxx\*(C'\fR is fairly flexible. You should use one
of the following formats (the 'T' is literal):
.PP
.Vb 2
\&        * YYYY\-MM\-DDTHH:MM:SS     (localtime)
\&        * YYYY\-MM\-DDTHH:MM:SSZ    (UTC)
.Ve
.PP
You can omit the YYYY-MM-DD, and then it refers to the current day. However
note that \fB?date=16:00:00\fR refers to 16:00 on the current day \*(-- this
may be in the future and so is unlikely to be useful.
.PP
You use this by adding the ?date= to the end of the \s-1URL\s0 for the stream.
For example:   \fBhttp://localhost:8080/test.asf?date=2002\-07\-26T23:05:00\fR.
.SH "OPTIONS"
.IX Header "OPTIONS"
All the numerical options, if not specified otherwise, accept in input
a string representing a number, which may contain one of the
International System number postfixes, for example 'K', 'M', 'G'.
If 'i' is appended after the postfix, powers of 2 are used instead of
powers of 10. The 'B' postfix multiplies the value for 8, and can be
appended after another postfix or used alone. This allows using for
example '\s-1KB\s0', 'MiB', 'G' and 'B' as postfix.
.PP
Options which do not take arguments are boolean options, and set the
corresponding value to true. They can be set to false by prefixing
with \*(L"no\*(R" the option name, for example using \*(L"\-nofoo\*(R" in the
command line will set to false the boolean option with name \*(L"foo\*(R".
.SS "Stream specifiers"
.IX Subsection "Stream specifiers"
Some options are applied per-stream, e.g. bitrate or codec. Stream specifiers
are used to precisely specify which stream(s) does a given option belong to.
.PP
A stream specifier is a string generally appended to the option name and
separated from it by a colon. E.g. \f(CW\*(C`\-codec:a:1 ac3\*(C'\fR option contains
\&\f(CW\*(C`a:1\*(C'\fR stream specifier, which matches the second audio stream. Therefore it
would select the ac3 codec for the second audio stream.
.PP
A stream specifier can match several streams, the option is then applied to all
of them. E.g. the stream specifier in \f(CW\*(C`\-b:a 128k\*(C'\fR matches all audio
streams.
.PP
An empty stream specifier matches all streams, for example \f(CW\*(C`\-codec copy\*(C'\fR
or \f(CW\*(C`\-codec: copy\*(C'\fR would copy all the streams without reencoding.
.PP
Possible forms of stream specifiers are:
.IP "\fIstream_index\fR" 4
.IX Item "stream_index"
Matches the stream with this index. E.g. \f(CW\*(C`\-threads:1 4\*(C'\fR would set the
thread count for the second stream to 4.
.IP "\fIstream_type\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "stream_type[:stream_index]"
\&\fIstream_type\fR is one of: 'v' for video, 'a' for audio, 's' for subtitle,
\&'d' for data and 't' for attachments. If \fIstream_index\fR is given, then
matches stream number \fIstream_index\fR of this type. Otherwise matches all
streams of this type.
.IP "\fBp:\fR\fIprogram_id\fR\fB[:\fR\fIstream_index\fR\fB]\fR" 4
.IX Item "p:program_id[:stream_index]"
If \fIstream_index\fR is given, then matches stream number \fIstream_index\fR in
program with id \fIprogram_id\fR. Otherwise matches all streams in this program.
.IP "\fB#\fR\fIstream_id\fR" 4
.IX Item "#stream_id"
Matches the stream by format-specific \s-1ID\s0.
.SS "Generic options"
.IX Subsection "Generic options"
These options are shared amongst the av* tools.
.IP "\fB\-L\fR" 4
.IX Item "-L"
Show license.
.IP "\fB\-h, \-?, \-help, \-\-help [\fR\fIarg\fR\fB]\fR" 4
.IX Item "-h, -?, -help, --help [arg]"
Show help. An optional parameter may be specified to print help about a specific
item.
.Sp
Possible values of \fIarg\fR are:
.RS 4
.IP "\fBdecoder=\fR\fIdecoder_name\fR" 4
.IX Item "decoder=decoder_name"
Print detailed information about the decoder named \fIdecoder_name\fR. Use the
\&\fB\-decoders\fR option to get a list of all decoders.
.IP "\fBencoder=\fR\fIencoder_name\fR" 4
.IX Item "encoder=encoder_name"
Print detailed information about the encoder named \fIencoder_name\fR. Use the
\&\fB\-encoders\fR option to get a list of all encoders.
.IP "\fBdemuxer=\fR\fIdemuxer_name\fR" 4
.IX Item "demuxer=demuxer_name"
Print detailed information about the demuxer named \fIdemuxer_name\fR. Use the
\&\fB\-formats\fR option to get a list of all demuxers and muxers.
.IP "\fBmuxer=\fR\fImuxer_name\fR" 4
.IX Item "muxer=muxer_name"
Print detailed information about the muxer named \fImuxer_name\fR. Use the
\&\fB\-formats\fR option to get a list of all muxers and demuxers.
.RE
.RS 4
.RE
.IP "\fB\-version\fR" 4
.IX Item "-version"
Show version.
.IP "\fB\-formats\fR" 4
.IX Item "-formats"
Show available formats.
.Sp
The fields preceding the format names have the following meanings:
.RS 4
.IP "\fBD\fR" 4
.IX Item "D"
Decoding available
.IP "\fBE\fR" 4
.IX Item "E"
Encoding available
.RE
.RS 4
.RE
.IP "\fB\-codecs\fR" 4
.IX Item "-codecs"
Show all codecs known to libavcodec.
.Sp
Note that the term 'codec' is used throughout this documentation as a shortcut
for what is more correctly called a media bitstream format.
.IP "\fB\-decoders\fR" 4
.IX Item "-decoders"
Show available decoders.
.IP "\fB\-encoders\fR" 4
.IX Item "-encoders"
Show all available encoders.
.IP "\fB\-bsfs\fR" 4
.IX Item "-bsfs"
Show available bitstream filters.
.IP "\fB\-protocols\fR" 4
.IX Item "-protocols"
Show available protocols.
.IP "\fB\-filters\fR" 4
.IX Item "-filters"
Show available libavfilter filters.
.IP "\fB\-pix_fmts\fR" 4
.IX Item "-pix_fmts"
Show available pixel formats.
.IP "\fB\-sample_fmts\fR" 4
.IX Item "-sample_fmts"
Show available sample formats.
.IP "\fB\-layouts\fR" 4
.IX Item "-layouts"
Show channel names and standard channel layouts.
.IP "\fB\-loglevel\fR \fIloglevel\fR \fB| \-v\fR \fIloglevel\fR" 4
.IX Item "-loglevel loglevel | -v loglevel"
Set the logging level used by the library.
\&\fIloglevel\fR is a number or a string containing one of the following values:
.RS 4
.IP "\fBquiet\fR" 4
.IX Item "quiet"
.PD 0
.IP "\fBpanic\fR" 4
.IX Item "panic"
.IP "\fBfatal\fR" 4
.IX Item "fatal"
.IP "\fBerror\fR" 4
.IX Item "error"
.IP "\fBwarning\fR" 4
.IX Item "warning"
.IP "\fBinfo\fR" 4
.IX Item "info"
.IP "\fBverbose\fR" 4
.IX Item "verbose"
.IP "\fBdebug\fR" 4
.IX Item "debug"
.RE
.RS 4
.PD
.Sp
By default the program logs to stderr, if coloring is supported by the
terminal, colors are used to mark errors and warnings. Log coloring
can be disabled setting the environment variable
\&\fB\s-1AV_LOG_FORCE_NOCOLOR\s0\fR or \fB\s-1NO_COLOR\s0\fR, or can be forced setting
the environment variable \fB\s-1AV_LOG_FORCE_COLOR\s0\fR.
The use of the environment variable \fB\s-1NO_COLOR\s0\fR is deprecated and
will be dropped in a following FFmpeg version.
.RE
.IP "\fB\-report\fR" 4
.IX Item "-report"
Dump full command line and console output to a file named
\&\f(CW\*(C`\f(CIprogram\f(CW\-\f(CIYYYYMMDD\f(CW\-\f(CIHHMMSS\f(CW.log\*(C'\fR in the current
directory.
This file can be useful for bug reports.
It also implies \f(CW\*(C`\-loglevel verbose\*(C'\fR.
.Sp
Note: setting the environment variable \f(CW\*(C`FFREPORT\*(C'\fR to any value has the
same effect.
.IP "\fB\-cpuflags flags (\fR\fIglobal\fR\fB)\fR" 4
.IX Item "-cpuflags flags (global)"
Allows setting and clearing cpu flags. This option is intended
for testing. Do not use it unless you know what you're doing.
.Sp
.Vb 3
\&        ffmpeg \-cpuflags \-sse+mmx ...
\&        ffmpeg \-cpuflags mmx ...
\&        ffmpeg \-cpuflags 0 ...
.Ve
.SS "AVOptions"
.IX Subsection "AVOptions"
These options are provided directly by the libavformat, libavdevice and
libavcodec libraries. To see the list of available AVOptions, use the
\&\fB\-help\fR option. They are separated into two categories:
.IP "\fBgeneric\fR" 4
.IX Item "generic"
These options can be set for any container, codec or device. Generic options
are listed under AVFormatContext options for containers/devices and under
AVCodecContext options for codecs.
.IP "\fBprivate\fR" 4
.IX Item "private"
These options are specific to the given container, device or codec. Private
options are listed under their corresponding containers/devices/codecs.
.PP
For example to write an ID3v2.3 header instead of a default ID3v2.4 to
an \s-1MP3\s0 file, use the \fBid3v2_version\fR private option of the \s-1MP3\s0
muxer:
.PP
.Vb 1
\&        ffmpeg \-i input.flac \-id3v2_version 3 out.mp3
.Ve
.PP
All codec AVOptions are obviously per-stream, so the chapter on stream
specifiers applies to them
.PP
Note \fB\-nooption\fR syntax cannot be used for boolean AVOptions,
use \fB\-option 0\fR/\fB\-option 1\fR.
.PP
Note2 old undocumented way of specifying per-stream AVOptions by prepending
v/a/s to the options name is now obsolete and will be removed soon.
.SS "Codec AVOptions"
.IX Subsection "Codec AVOptions"
.IP "\fB\-b[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-b[:stream_specifier] integer (output,audio,video)"
set bitrate (in bits/s)
.IP "\fB\-ab[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-ab[:stream_specifier] integer (output,audio)"
set bitrate (in bits/s)
.IP "\fB\-bt[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-bt[:stream_specifier] integer (output,video)"
Set video bitrate tolerance (in bits/s). In 1\-pass mode, bitrate tolerance specifies how far ratecontrol is willing to deviate from the target average bitrate value. This is not related to min/max bitrate. Lowering tolerance too much has an adverse effect on quality.
.IP "\fB\-flags[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput/output,audio,video,subtitles\fR\fB)\fR" 4
.IX Item "-flags[:stream_specifier] flags (input/output,audio,video,subtitles)"
Possible values:
.RS 4
.IP "\fBmv4\fR" 4
.IX Item "mv4"
use four motion vector by macroblock (mpeg4)
.IP "\fBqpel\fR" 4
.IX Item "qpel"
use 1/4 pel motion compensation
.IP "\fBloop\fR" 4
.IX Item "loop"
use loop filter
.IP "\fBqscale\fR" 4
.IX Item "qscale"
use fixed qscale
.IP "\fBgmc\fR" 4
.IX Item "gmc"
use gmc
.IP "\fBmv0\fR" 4
.IX Item "mv0"
always try a mb with mv=<0,0>
.IP "\fBinput_preserved\fR" 4
.IX Item "input_preserved"
.PD 0
.IP "\fBpass1\fR" 4
.IX Item "pass1"
.PD
use internal 2pass ratecontrol in first  pass mode
.IP "\fBpass2\fR" 4
.IX Item "pass2"
use internal 2pass ratecontrol in second pass mode
.IP "\fBgray\fR" 4
.IX Item "gray"
only decode/encode grayscale
.IP "\fBemu_edge\fR" 4
.IX Item "emu_edge"
don't draw edges
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
error[?] variables will be set during encoding
.IP "\fBtruncated\fR" 4
.IX Item "truncated"
.PD 0
.IP "\fBnaq\fR" 4
.IX Item "naq"
.PD
normalize adaptive quantization
.IP "\fBildct\fR" 4
.IX Item "ildct"
use interlaced dct
.IP "\fBlow_delay\fR" 4
.IX Item "low_delay"
force low delay
.IP "\fBglobal_header\fR" 4
.IX Item "global_header"
place global headers in extradata instead of every keyframe
.IP "\fBbitexact\fR" 4
.IX Item "bitexact"
use only bitexact stuff (except (i)dct)
.IP "\fBaic\fR" 4
.IX Item "aic"
h263 advanced intra coding / mpeg4 ac prediction
.IP "\fBcbp\fR" 4
.IX Item "cbp"
Deprecated, use mpegvideo private options instead
.IP "\fBqprd\fR" 4
.IX Item "qprd"
Deprecated, use mpegvideo private options instead
.IP "\fBilme\fR" 4
.IX Item "ilme"
interlaced motion estimation
.IP "\fBcgop\fR" 4
.IX Item "cgop"
closed gop
.RE
.RS 4
.RE
.IP "\fB\-sub_id[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-sub_id[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-me_method[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-me_method[:stream_specifier] integer (output,video)"
.PD
set motion estimation method
.Sp
Possible values:
.RS 4
.IP "\fBzero\fR" 4
.IX Item "zero"
zero motion estimation (fastest)
.IP "\fBfull\fR" 4
.IX Item "full"
full motion estimation (slowest)
.IP "\fBepzs\fR" 4
.IX Item "epzs"
\&\s-1EPZS\s0 motion estimation (default)
.IP "\fBesa\fR" 4
.IX Item "esa"
esa motion estimation (alias for full)
.IP "\fBtesa\fR" 4
.IX Item "tesa"
tesa motion estimation
.IP "\fBdia\fR" 4
.IX Item "dia"
dia motion estimation (alias for epzs)
.IP "\fBlog\fR" 4
.IX Item "log"
log motion estimation
.IP "\fBphods\fR" 4
.IX Item "phods"
phods motion estimation
.IP "\fBx1\fR" 4
.IX Item "x1"
X1 motion estimation
.IP "\fBhex\fR" 4
.IX Item "hex"
hex motion estimation
.IP "\fBumh\fR" 4
.IX Item "umh"
umh motion estimation
.IP "\fBiter\fR" 4
.IX Item "iter"
iter motion estimation
.RE
.RS 4
.RE
.IP "\fB\-extradata_size[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-extradata_size[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-time_base[:stream_specifier]\fR \fIrational number\fR \fB()\fR" 4
.IX Item "-time_base[:stream_specifier] rational number ()"
.IP "\fB\-g[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-g[:stream_specifier] integer (output,video)"
.PD
set the group of picture size
.IP "\fB\-ar[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,audio\fR\fB)\fR" 4
.IX Item "-ar[:stream_specifier] integer (input/output,audio)"
set audio sampling rate (in Hz)
.IP "\fB\-ac[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,audio\fR\fB)\fR" 4
.IX Item "-ac[:stream_specifier] integer (input/output,audio)"
set number of audio channels
.IP "\fB\-cutoff[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-cutoff[:stream_specifier] integer (output,audio)"
set cutoff bandwidth
.IP "\fB\-frame_size[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-frame_size[:stream_specifier] integer (output,audio)"
.PD 0
.IP "\fB\-frame_number[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-frame_number[:stream_specifier] integer ()"
.IP "\fB\-delay[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-delay[:stream_specifier] integer ()"
.IP "\fB\-qcomp[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qcomp[:stream_specifier] float (output,video)"
.PD
video quantizer scale compression (\s-1VBR\s0). Constant of ratecontrol equation. Recommended range for default rc_eq: 0.0\-1.0
.IP "\fB\-qblur[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qblur[:stream_specifier] float (output,video)"
video quantizer scale blur (\s-1VBR\s0)
.IP "\fB\-qmin[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qmin[:stream_specifier] integer (output,video)"
min video quantizer scale (\s-1VBR\s0)
.IP "\fB\-qmax[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qmax[:stream_specifier] integer (output,video)"
max video quantizer scale (\s-1VBR\s0)
.IP "\fB\-qdiff[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qdiff[:stream_specifier] integer (output,video)"
max difference between the quantizer scale (\s-1VBR\s0)
.IP "\fB\-bf[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-bf[:stream_specifier] integer (output,video)"
use 'frames' B frames
.IP "\fB\-b_qfactor[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-b_qfactor[:stream_specifier] float (output,video)"
qp factor between p and b frames
.IP "\fB\-rc_strategy[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_strategy[:stream_specifier] integer (output,video)"
ratecontrol method
.IP "\fB\-b_strategy[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-b_strategy[:stream_specifier] integer (output,video)"
strategy to choose between I/P/B\-frames
.IP "\fB\-ps[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-ps[:stream_specifier] integer (output,video)"
rtp payload size in bytes
.IP "\fB\-mv_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-mv_bits[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-header_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-header_bits[:stream_specifier] integer ()"
.IP "\fB\-i_tex_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-i_tex_bits[:stream_specifier] integer ()"
.IP "\fB\-p_tex_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-p_tex_bits[:stream_specifier] integer ()"
.IP "\fB\-i_count[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-i_count[:stream_specifier] integer ()"
.IP "\fB\-p_count[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-p_count[:stream_specifier] integer ()"
.IP "\fB\-skip_count[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-skip_count[:stream_specifier] integer ()"
.IP "\fB\-misc_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-misc_bits[:stream_specifier] integer ()"
.IP "\fB\-frame_bits[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-frame_bits[:stream_specifier] integer ()"
.IP "\fB\-codec_tag[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-codec_tag[:stream_specifier] integer ()"
.IP "\fB\-bug[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-bug[:stream_specifier] flags (input,video)"
.PD
workaround not auto detected encoder bugs
.Sp
Possible values:
.RS 4
.IP "\fBautodetect\fR" 4
.IX Item "autodetect"
.PD 0
.IP "\fBold_msmpeg4\fR" 4
.IX Item "old_msmpeg4"
.PD
some old lavc generated msmpeg4v3 files (no autodetection)
.IP "\fBxvid_ilace\fR" 4
.IX Item "xvid_ilace"
Xvid interlacing bug (autodetected if fourcc==XVIX)
.IP "\fBump4\fR" 4
.IX Item "ump4"
(autodetected if fourcc==UMP4)
.IP "\fBno_padding\fR" 4
.IX Item "no_padding"
padding bug (autodetected)
.IP "\fBamv\fR" 4
.IX Item "amv"
.PD 0
.IP "\fBac_vlc\fR" 4
.IX Item "ac_vlc"
.PD
illegal vlc bug (autodetected per fourcc)
.IP "\fBqpel_chroma\fR" 4
.IX Item "qpel_chroma"
.PD 0
.IP "\fBstd_qpel\fR" 4
.IX Item "std_qpel"
.PD
old standard qpel (autodetected per fourcc/version)
.IP "\fBqpel_chroma2\fR" 4
.IX Item "qpel_chroma2"
.PD 0
.IP "\fBdirect_blocksize\fR" 4
.IX Item "direct_blocksize"
.PD
direct-qpel-blocksize bug (autodetected per fourcc/version)
.IP "\fBedge\fR" 4
.IX Item "edge"
edge padding bug (autodetected per fourcc/version)
.IP "\fBhpel_chroma\fR" 4
.IX Item "hpel_chroma"
.PD 0
.IP "\fBdc_clip\fR" 4
.IX Item "dc_clip"
.IP "\fBms\fR" 4
.IX Item "ms"
.PD
workaround various bugs in microsofts broken decoders
.IP "\fBtrunc\fR" 4
.IX Item "trunc"
trancated frames
.RE
.RS 4
.RE
.IP "\fB\-lelim[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-lelim[:stream_specifier] integer (output,video)"
single coefficient elimination threshold for luminance (negative values also consider dc coefficient)
.IP "\fB\-celim[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-celim[:stream_specifier] integer (output,video)"
single coefficient elimination threshold for chrominance (negative values also consider dc coefficient)
.IP "\fB\-strict[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,audio,video\fR\fB)\fR" 4
.IX Item "-strict[:stream_specifier] integer (input/output,audio,video)"
how strictly to follow the standards
.Sp
Possible values:
.RS 4
.IP "\fBvery\fR" 4
.IX Item "very"
strictly conform to a older more strict version of the spec or reference software
.IP "\fBstrict\fR" 4
.IX Item "strict"
strictly conform to all the things in the spec no matter what consequences
.IP "\fBnormal\fR" 4
.IX Item "normal"
.PD 0
.IP "\fBunofficial\fR" 4
.IX Item "unofficial"
.PD
allow unofficial extensions
.IP "\fBexperimental\fR" 4
.IX Item "experimental"
allow non standardized experimental things
.RE
.RS 4
.RE
.IP "\fB\-b_qoffset[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-b_qoffset[:stream_specifier] float (output,video)"
qp offset between P and B frames
.IP "\fB\-err_detect[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput,audio,video\fR\fB)\fR" 4
.IX Item "-err_detect[:stream_specifier] flags (input,audio,video)"
set error detection flags
.Sp
Possible values:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
verify embedded CRCs
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
detect bitstream specification deviations
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
detect improper bitstream length
.IP "\fBexplode\fR" 4
.IX Item "explode"
abort decoding on minor error detection
.IP "\fBcareful\fR" 4
.IX Item "careful"
consider things that violate the spec and have not been seen in the wild as errors
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
consider all spec non compliancies as errors
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
consider things that a sane encoder should not do as an error
.RE
.RS 4
.RE
.IP "\fB\-has_b_frames[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-has_b_frames[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-block_align[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-block_align[:stream_specifier] integer ()"
.IP "\fB\-mpeg_quant[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mpeg_quant[:stream_specifier] integer (output,video)"
.PD
use \s-1MPEG\s0 quantizers instead of H.263
.IP "\fB\-stats_out[:stream_specifier]\fR \fIstring\fR \fB()\fR" 4
.IX Item "-stats_out[:stream_specifier] string ()"
.PD 0
.IP "\fB\-qsquish[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qsquish[:stream_specifier] float (output,video)"
.PD
how to keep quantizer between qmin and qmax (0 = clip, 1 = use differentiable function)
.IP "\fB\-rc_qmod_amp[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_qmod_amp[:stream_specifier] float (output,video)"
experimental quantizer modulation
.IP "\fB\-rc_qmod_freq[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_qmod_freq[:stream_specifier] integer (output,video)"
experimental quantizer modulation
.IP "\fB\-rc_override_count[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-rc_override_count[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-rc_eq[:stream_specifier]\fR \fIstring\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_eq[:stream_specifier] string (output,video)"
.PD
Set rate control equation. When computing the expression, besides the standard functions defined in the section 'Expression Evaluation', the following functions are available: bits2qp(bits), qp2bits(qp). Also the following constants are available: iTex pTex tex mv fCode iCount mcVar var isI isP isB avgQP qComp avgIITex avgPITex avgPPTex avgBPTex avgTex.
.IP "\fB\-maxrate[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-maxrate[:stream_specifier] integer (output,audio,video)"
Set max bitrate tolerance (in bits/s). Requires bufsize to be set.
.IP "\fB\-minrate[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-minrate[:stream_specifier] integer (output,audio,video)"
Set min bitrate tolerance (in bits/s). Most useful in setting up a \s-1CBR\s0 encode. It is of little use elsewise.
.IP "\fB\-bufsize[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-bufsize[:stream_specifier] integer (output,audio,video)"
set ratecontrol buffer size (in bits)
.IP "\fB\-rc_buf_aggressivity[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_buf_aggressivity[:stream_specifier] float (output,video)"
currently useless
.IP "\fB\-i_qfactor[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-i_qfactor[:stream_specifier] float (output,video)"
qp factor between P and I frames
.IP "\fB\-i_qoffset[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-i_qoffset[:stream_specifier] float (output,video)"
qp offset between P and I frames
.IP "\fB\-rc_init_cplx[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_init_cplx[:stream_specifier] float (output,video)"
initial complexity for 1\-pass encoding
.IP "\fB\-dct[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-dct[:stream_specifier] integer (output,video)"
\&\s-1DCT\s0 algorithm
.Sp
Possible values:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
autoselect a good one (default)
.IP "\fBfastint\fR" 4
.IX Item "fastint"
fast integer
.IP "\fBint\fR" 4
.IX Item "int"
accurate integer
.IP "\fBmmx\fR" 4
.IX Item "mmx"
.PD 0
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.IP "\fBfaan\fR" 4
.IX Item "faan"
.PD
floating point \s-1AAN\s0 \s-1DCT\s0
.RE
.RS 4
.RE
.IP "\fB\-lumi_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-lumi_mask[:stream_specifier] float (output,video)"
compresses bright areas stronger than medium ones
.IP "\fB\-tcplx_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-tcplx_mask[:stream_specifier] float (output,video)"
temporal complexity masking
.IP "\fB\-scplx_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-scplx_mask[:stream_specifier] float (output,video)"
spatial complexity masking
.IP "\fB\-p_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-p_mask[:stream_specifier] float (output,video)"
inter masking
.IP "\fB\-dark_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-dark_mask[:stream_specifier] float (output,video)"
compresses dark areas stronger than medium ones
.IP "\fB\-idct[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-idct[:stream_specifier] integer (input/output,video)"
select \s-1IDCT\s0 implementation
.Sp
Possible values:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
.PD 0
.IP "\fBint\fR" 4
.IX Item "int"
.IP "\fBsimple\fR" 4
.IX Item "simple"
.IP "\fBsimplemmx\fR" 4
.IX Item "simplemmx"
.IP "\fBlibmpeg2mmx\fR" 4
.IX Item "libmpeg2mmx"
.IP "\fBmmi\fR" 4
.IX Item "mmi"
.IP "\fBarm\fR" 4
.IX Item "arm"
.IP "\fBaltivec\fR" 4
.IX Item "altivec"
.IP "\fBsh4\fR" 4
.IX Item "sh4"
.IP "\fBsimplearm\fR" 4
.IX Item "simplearm"
.IP "\fBsimplearmv5te\fR" 4
.IX Item "simplearmv5te"
.IP "\fBsimplearmv6\fR" 4
.IX Item "simplearmv6"
.IP "\fBsimpleneon\fR" 4
.IX Item "simpleneon"
.IP "\fBsimplealpha\fR" 4
.IX Item "simplealpha"
.IP "\fBh264\fR" 4
.IX Item "h264"
.IP "\fBvp3\fR" 4
.IX Item "vp3"
.IP "\fBipp\fR" 4
.IX Item "ipp"
.IP "\fBxvidmmx\fR" 4
.IX Item "xvidmmx"
.IP "\fBfaani\fR" 4
.IX Item "faani"
.PD
floating point \s-1AAN\s0 \s-1IDCT\s0
.RE
.RS 4
.RE
.IP "\fB\-slice_count[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-slice_count[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-ec[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-ec[:stream_specifier] flags (input,video)"
.PD
set error concealment strategy
.Sp
Possible values:
.RS 4
.IP "\fBguess_mvs\fR" 4
.IX Item "guess_mvs"
iterative motion vector (\s-1MV\s0) search (slow)
.IP "\fBdeblock\fR" 4
.IX Item "deblock"
use strong deblock filter for damaged MBs
.RE
.RS 4
.RE
.IP "\fB\-bits_per_coded_sample[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-bits_per_coded_sample[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-pred[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-pred[:stream_specifier] integer (output,video)"
.PD
prediction method
.Sp
Possible values:
.RS 4
.IP "\fBleft\fR" 4
.IX Item "left"
.PD 0
.IP "\fBplane\fR" 4
.IX Item "plane"
.IP "\fBmedian\fR" 4
.IX Item "median"
.RE
.RS 4
.RE
.IP "\fB\-aspect[:stream_specifier]\fR \fIrational number\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-aspect[:stream_specifier] rational number (output,video)"
.PD
sample aspect ratio
.IP "\fB\-debug[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput/output,audio,video,subtitles\fR\fB)\fR" 4
.IX Item "-debug[:stream_specifier] flags (input/output,audio,video,subtitles)"
print specific debug info
.Sp
Possible values:
.RS 4
.IP "\fBpict\fR" 4
.IX Item "pict"
picture info
.IP "\fBrc\fR" 4
.IX Item "rc"
rate control
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
.PD 0
.IP "\fBmb_type\fR" 4
.IX Item "mb_type"
.PD
macroblock (\s-1MB\s0) type
.IP "\fBqp\fR" 4
.IX Item "qp"
per-block quantization parameter (\s-1QP\s0)
.IP "\fBmv\fR" 4
.IX Item "mv"
motion vector
.IP "\fBdct_coeff\fR" 4
.IX Item "dct_coeff"
.PD 0
.IP "\fBskip\fR" 4
.IX Item "skip"
.IP "\fBstartcode\fR" 4
.IX Item "startcode"
.IP "\fBpts\fR" 4
.IX Item "pts"
.IP "\fBer\fR" 4
.IX Item "er"
.PD
error recognition
.IP "\fBmmco\fR" 4
.IX Item "mmco"
memory management control operations (H.264)
.IP "\fBbugs\fR" 4
.IX Item "bugs"
.PD 0
.IP "\fBvis_qp\fR" 4
.IX Item "vis_qp"
.PD
visualize quantization parameter (\s-1QP\s0), lower \s-1QP\s0 are tinted greener
.IP "\fBvis_mb_type\fR" 4
.IX Item "vis_mb_type"
visualize block types
.IP "\fBbuffers\fR" 4
.IX Item "buffers"
picture buffer allocations
.IP "\fBthread_ops\fR" 4
.IX Item "thread_ops"
threading operations
.RE
.RS 4
.RE
.IP "\fB\-vismv[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-vismv[:stream_specifier] integer (input,video)"
visualize motion vectors (MVs)
.Sp
Possible values:
.RS 4
.IP "\fBpf\fR" 4
.IX Item "pf"
forward predicted MVs of P\-frames
.IP "\fBbf\fR" 4
.IX Item "bf"
forward predicted MVs of B\-frames
.IP "\fBbb\fR" 4
.IX Item "bb"
backward predicted MVs of B\-frames
.RE
.RS 4
.RE
.IP "\fB\-cmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-cmp[:stream_specifier] integer (output,video)"
full pel me compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-subcmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-subcmp[:stream_specifier] integer (output,video)"
.PD
sub pel me compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-mbcmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mbcmp[:stream_specifier] integer (output,video)"
.PD
macroblock compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-ildctcmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-ildctcmp[:stream_specifier] integer (output,video)"
.PD
interlaced dct compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-dia_size[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-dia_size[:stream_specifier] integer (output,video)"
.PD
diamond type & size for motion estimation
.IP "\fB\-last_pred[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-last_pred[:stream_specifier] integer (output,video)"
amount of motion predictors from the previous frame
.IP "\fB\-preme[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-preme[:stream_specifier] integer (output,video)"
pre motion estimation
.IP "\fB\-precmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-precmp[:stream_specifier] integer (output,video)"
pre motion estimation compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-pre_dia_size[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-pre_dia_size[:stream_specifier] integer (output,video)"
.PD
diamond type & size for motion estimation pre-pass
.IP "\fB\-subq[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-subq[:stream_specifier] integer (output,video)"
sub pel motion estimation quality
.IP "\fB\-dtg_active_format[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-dtg_active_format[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-me_range[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-me_range[:stream_specifier] integer (output,video)"
.PD
limit motion vectors range (1023 for DivX player)
.IP "\fB\-ibias[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-ibias[:stream_specifier] integer (output,video)"
intra quant bias
.IP "\fB\-pbias[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-pbias[:stream_specifier] integer (output,video)"
inter quant bias
.IP "\fB\-color_table_id[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-color_table_id[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-global_quality[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-global_quality[:stream_specifier] integer (output,audio,video)"
.IP "\fB\-coder[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-coder[:stream_specifier] integer (output,video)"
.PD
Possible values:
.RS 4
.IP "\fBvlc\fR" 4
.IX Item "vlc"
variable length coder / huffman coder
.IP "\fBac\fR" 4
.IX Item "ac"
arithmetic coder
.IP "\fBraw\fR" 4
.IX Item "raw"
raw (no encoding)
.IP "\fBrle\fR" 4
.IX Item "rle"
run-length coder
.IP "\fBdeflate\fR" 4
.IX Item "deflate"
deflate-based coder
.RE
.RS 4
.RE
.IP "\fB\-context[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-context[:stream_specifier] integer (output,video)"
context model
.IP "\fB\-slice_flags[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-slice_flags[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-xvmc_acceleration[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-xvmc_acceleration[:stream_specifier] integer ()"
.IP "\fB\-mbd[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mbd[:stream_specifier] integer (output,video)"
.PD
macroblock decision algorithm (high quality mode)
.Sp
Possible values:
.RS 4
.IP "\fBsimple\fR" 4
.IX Item "simple"
use mbcmp (default)
.IP "\fBbits\fR" 4
.IX Item "bits"
use fewest bits
.IP "\fBrd\fR" 4
.IX Item "rd"
use best rate distortion
.RE
.RS 4
.RE
.IP "\fB\-stream_codec_tag[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-stream_codec_tag[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-sc_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-sc_threshold[:stream_specifier] integer (output,video)"
.PD
scene change threshold
.IP "\fB\-lmin[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-lmin[:stream_specifier] integer (output,video)"
min lagrange factor (\s-1VBR\s0)
.IP "\fB\-lmax[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-lmax[:stream_specifier] integer (output,video)"
max lagrange factor (\s-1VBR\s0)
.IP "\fB\-nr[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-nr[:stream_specifier] integer (output,video)"
noise reduction
.IP "\fB\-rc_init_occupancy[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_init_occupancy[:stream_specifier] integer (output,video)"
number of bits which should be loaded into the rc buffer before decoding starts
.IP "\fB\-inter_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-inter_threshold[:stream_specifier] integer (output,video)"
.PD 0
.IP "\fB\-flags2[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput/output,audio,video\fR\fB)\fR" 4
.IX Item "-flags2[:stream_specifier] flags (input/output,audio,video)"
.PD
Possible values:
.RS 4
.IP "\fBfast\fR" 4
.IX Item "fast"
allow non spec compliant speedup tricks
.IP "\fBsgop\fR" 4
.IX Item "sgop"
Deprecated, use mpegvideo private options instead
.IP "\fBnoout\fR" 4
.IX Item "noout"
skip bitstream encoding
.IP "\fBlocal_header\fR" 4
.IX Item "local_header"
place global headers at every keyframe instead of in extradata
.IP "\fBchunks\fR" 4
.IX Item "chunks"
Frame data might be split into multiple chunks
.IP "\fBshowall\fR" 4
.IX Item "showall"
Show all frames before the first keyframe
.IP "\fBskiprd\fR" 4
.IX Item "skiprd"
Deprecated, use mpegvideo private options instead
.RE
.RS 4
.RE
.IP "\fB\-error[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-error[:stream_specifier] integer (output,video)"
.PD 0
.IP "\fB\-qns[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-qns[:stream_specifier] integer (output,video)"
.PD
deprecated, use mpegvideo private options instead
.IP "\fB\-threads[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-threads[:stream_specifier] integer (input/output,video)"
Possible values:
.RS 4
.IP "\fBauto\fR" 4
.IX Item "auto"
detect a good number of threads
.RE
.RS 4
.RE
.IP "\fB\-me_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-me_threshold[:stream_specifier] integer (output,video)"
motion estimaton threshold
.IP "\fB\-mb_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mb_threshold[:stream_specifier] integer (output,video)"
macroblock threshold
.IP "\fB\-dc[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-dc[:stream_specifier] integer (output,video)"
intra_dc_precision
.IP "\fB\-nssew[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-nssew[:stream_specifier] integer (output,video)"
nsse weight
.IP "\fB\-skip_top[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-skip_top[:stream_specifier] integer (input,video)"
number of macroblock rows at the top which are skipped
.IP "\fB\-skip_bottom[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-skip_bottom[:stream_specifier] integer (input,video)"
number of macroblock rows at the bottom which are skipped
.IP "\fB\-profile[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-profile[:stream_specifier] integer (output,audio,video)"
Possible values:
.RS 4
.IP "\fBunknown\fR" 4
.IX Item "unknown"
.PD 0
.IP "\fBaac_main\fR" 4
.IX Item "aac_main"
.IP "\fBaac_low\fR" 4
.IX Item "aac_low"
.IP "\fBaac_ssr\fR" 4
.IX Item "aac_ssr"
.IP "\fBaac_ltp\fR" 4
.IX Item "aac_ltp"
.IP "\fBaac_he\fR" 4
.IX Item "aac_he"
.IP "\fBaac_he_v2\fR" 4
.IX Item "aac_he_v2"
.IP "\fBaac_ld\fR" 4
.IX Item "aac_ld"
.IP "\fBaac_eld\fR" 4
.IX Item "aac_eld"
.IP "\fBdts\fR" 4
.IX Item "dts"
.IP "\fBdts_es\fR" 4
.IX Item "dts_es"
.IP "\fBdts_96_24\fR" 4
.IX Item "dts_96_24"
.IP "\fBdts_hd_hra\fR" 4
.IX Item "dts_hd_hra"
.IP "\fBdts_hd_ma\fR" 4
.IX Item "dts_hd_ma"
.RE
.RS 4
.RE
.IP "\fB\-level[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-level[:stream_specifier] integer (output,audio,video)"
.PD
Possible values:
.RS 4
.IP "\fBunknown\fR" 4
.IX Item "unknown"
.RE
.RS 4
.RE
.PD 0
.IP "\fB\-lowres[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,audio,video\fR\fB)\fR" 4
.IX Item "-lowres[:stream_specifier] integer (input,audio,video)"
.PD
decode at 1= 1/2, 2=1/4, 3=1/8 resolutions
.IP "\fB\-skip_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-skip_threshold[:stream_specifier] integer (output,video)"
frame skip threshold
.IP "\fB\-skip_factor[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-skip_factor[:stream_specifier] integer (output,video)"
frame skip factor
.IP "\fB\-skip_exp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-skip_exp[:stream_specifier] integer (output,video)"
frame skip exponent
.IP "\fB\-skipcmp[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-skipcmp[:stream_specifier] integer (output,video)"
frame skip compare function
.Sp
Possible values:
.RS 4
.IP "\fBsad\fR" 4
.IX Item "sad"
sum of absolute differences, fast (default)
.IP "\fBsse\fR" 4
.IX Item "sse"
sum of squared errors
.IP "\fBsatd\fR" 4
.IX Item "satd"
sum of absolute Hadamard transformed differences
.IP "\fBdct\fR" 4
.IX Item "dct"
sum of absolute \s-1DCT\s0 transformed differences
.IP "\fBpsnr\fR" 4
.IX Item "psnr"
sum of squared quantization errors (avoid, low quality)
.IP "\fBbit\fR" 4
.IX Item "bit"
number of bits needed for the block
.IP "\fBrd\fR" 4
.IX Item "rd"
rate distortion optimal, slow
.IP "\fBzero\fR" 4
.IX Item "zero"
0
.IP "\fBvsad\fR" 4
.IX Item "vsad"
sum of absolute vertical differences
.IP "\fBvsse\fR" 4
.IX Item "vsse"
sum of squared vertical differences
.IP "\fBnsse\fR" 4
.IX Item "nsse"
noise preserving sum of squared differences
.IP "\fBw53\fR" 4
.IX Item "w53"
5/3 wavelet, only used in snow
.IP "\fBw97\fR" 4
.IX Item "w97"
9/7 wavelet, only used in snow
.IP "\fBdctmax\fR" 4
.IX Item "dctmax"
.PD 0
.IP "\fBchroma\fR" 4
.IX Item "chroma"
.RE
.RS 4
.RE
.IP "\fB\-border_mask[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-border_mask[:stream_specifier] float (output,video)"
.PD
increases the quantizer for macroblocks close to borders
.IP "\fB\-mblmin[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mblmin[:stream_specifier] integer (output,video)"
min macroblock lagrange factor (\s-1VBR\s0)
.IP "\fB\-mblmax[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mblmax[:stream_specifier] integer (output,video)"
max macroblock lagrange factor (\s-1VBR\s0)
.IP "\fB\-mepc[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mepc[:stream_specifier] integer (output,video)"
motion estimation bitrate penalty compensation (1.0 = 256)
.IP "\fB\-skip_loop_filter[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-skip_loop_filter[:stream_specifier] integer (input,video)"
Possible values:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
.PD 0
.IP "\fBdefault\fR" 4
.IX Item "default"
.IP "\fBnoref\fR" 4
.IX Item "noref"
.IP "\fBbidir\fR" 4
.IX Item "bidir"
.IP "\fBnokey\fR" 4
.IX Item "nokey"
.IP "\fBall\fR" 4
.IX Item "all"
.RE
.RS 4
.RE
.IP "\fB\-skip_idct[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-skip_idct[:stream_specifier] integer (input,video)"
.PD
Possible values:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
.PD 0
.IP "\fBdefault\fR" 4
.IX Item "default"
.IP "\fBnoref\fR" 4
.IX Item "noref"
.IP "\fBbidir\fR" 4
.IX Item "bidir"
.IP "\fBnokey\fR" 4
.IX Item "nokey"
.IP "\fBall\fR" 4
.IX Item "all"
.RE
.RS 4
.RE
.IP "\fB\-skip_frame[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,video\fR\fB)\fR" 4
.IX Item "-skip_frame[:stream_specifier] integer (input,video)"
.PD
Possible values:
.RS 4
.IP "\fBnone\fR" 4
.IX Item "none"
.PD 0
.IP "\fBdefault\fR" 4
.IX Item "default"
.IP "\fBnoref\fR" 4
.IX Item "noref"
.IP "\fBbidir\fR" 4
.IX Item "bidir"
.IP "\fBnokey\fR" 4
.IX Item "nokey"
.IP "\fBall\fR" 4
.IX Item "all"
.RE
.RS 4
.RE
.IP "\fB\-bidir_refine[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-bidir_refine[:stream_specifier] integer (output,video)"
.PD
refine the two motion vectors used in bidirectional macroblocks
.IP "\fB\-brd_scale[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-brd_scale[:stream_specifier] integer (output,video)"
downscales frames for dynamic B\-frame decision
.IP "\fB\-keyint_min[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-keyint_min[:stream_specifier] integer (output,video)"
minimum interval between IDR-frames
.IP "\fB\-refs[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-refs[:stream_specifier] integer (output,video)"
reference frames to consider for motion compensation
.IP "\fB\-chromaoffset[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-chromaoffset[:stream_specifier] integer (output,video)"
chroma qp offset from luma
.IP "\fB\-trellis[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-trellis[:stream_specifier] integer (output,audio,video)"
rate-distortion optimal quantization
.IP "\fB\-sc_factor[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-sc_factor[:stream_specifier] integer (output,video)"
multiplied by qscale for each frame and added to scene_change_score
.IP "\fB\-mv0_threshold[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-mv0_threshold[:stream_specifier] integer (output,video)"
.PD 0
.IP "\fB\-b_sensitivity[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-b_sensitivity[:stream_specifier] integer (output,video)"
.PD
adjusts sensitivity of b_frame_strategy 1
.IP "\fB\-compression_level[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio,video\fR\fB)\fR" 4
.IX Item "-compression_level[:stream_specifier] integer (output,audio,video)"
.PD 0
.IP "\fB\-min_prediction_order[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-min_prediction_order[:stream_specifier] integer (output,audio)"
.IP "\fB\-max_prediction_order[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-max_prediction_order[:stream_specifier] integer (output,audio)"
.IP "\fB\-timecode_frame_start[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-timecode_frame_start[:stream_specifier] integer (output,video)"
.PD
\&\s-1GOP\s0 timecode frame start number, in non drop frame format
.IP "\fB\-request_channels[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,audio\fR\fB)\fR" 4
.IX Item "-request_channels[:stream_specifier] integer (input,audio)"
set desired number of audio channels
.IP "\fB\-bits_per_raw_sample[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-bits_per_raw_sample[:stream_specifier] integer ()"
.PD 0
.IP "\fB\-channel_layout[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,audio\fR\fB)\fR" 4
.IX Item "-channel_layout[:stream_specifier] integer (input/output,audio)"
.PD
Possible values:
.IP "\fB\-request_channel_layout[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,audio\fR\fB)\fR" 4
.IX Item "-request_channel_layout[:stream_specifier] integer (input,audio)"
Possible values:
.IP "\fB\-rc_max_vbv_use[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_max_vbv_use[:stream_specifier] float (output,video)"
.PD 0
.IP "\fB\-rc_min_vbv_use[:stream_specifier]\fR \fIfloat\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-rc_min_vbv_use[:stream_specifier] float (output,video)"
.IP "\fB\-ticks_per_frame[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,audio,video\fR\fB)\fR" 4
.IX Item "-ticks_per_frame[:stream_specifier] integer (input/output,audio,video)"
.IP "\fB\-color_primaries[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-color_primaries[:stream_specifier] integer (input/output,video)"
.IP "\fB\-color_trc[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-color_trc[:stream_specifier] integer (input/output,video)"
.IP "\fB\-colorspace[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-colorspace[:stream_specifier] integer (input/output,video)"
.IP "\fB\-color_range[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-color_range[:stream_specifier] integer (input/output,video)"
.IP "\fB\-chroma_sample_location[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-chroma_sample_location[:stream_specifier] integer (input/output,video)"
.IP "\fB\-log_level_offset[:stream_specifier]\fR \fIinteger\fR \fB()\fR" 4
.IX Item "-log_level_offset[:stream_specifier] integer ()"
.PD
set the log level offset
.IP "\fB\-slices[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,video\fR\fB)\fR" 4
.IX Item "-slices[:stream_specifier] integer (output,video)"
number of slices, used in parallelized encoding
.IP "\fB\-thread_type[:stream_specifier]\fR \fIflags\fR \fB(\fR\fIinput/output,video\fR\fB)\fR" 4
.IX Item "-thread_type[:stream_specifier] flags (input/output,video)"
select multithreading type
.Sp
Possible values:
.RS 4
.IP "\fBslice\fR" 4
.IX Item "slice"
.PD 0
.IP "\fBframe\fR" 4
.IX Item "frame"
.RE
.RS 4
.RE
.IP "\fB\-audio_service_type[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIoutput,audio\fR\fB)\fR" 4
.IX Item "-audio_service_type[:stream_specifier] integer (output,audio)"
.PD
audio service type
.Sp
Possible values:
.RS 4
.IP "\fBma\fR" 4
.IX Item "ma"
Main Audio Service
.IP "\fBef\fR" 4
.IX Item "ef"
Effects
.IP "\fBvi\fR" 4
.IX Item "vi"
Visually Impaired
.IP "\fBhi\fR" 4
.IX Item "hi"
Hearing Impaired
.IP "\fBdi\fR" 4
.IX Item "di"
Dialogue
.IP "\fBco\fR" 4
.IX Item "co"
Commentary
.IP "\fBem\fR" 4
.IX Item "em"
Emergency
.IP "\fBvo\fR" 4
.IX Item "vo"
Voice Over
.IP "\fBka\fR" 4
.IX Item "ka"
Karaoke
.RE
.RS 4
.RE
.IP "\fB\-request_sample_fmt[:stream_specifier]\fR \fIinteger\fR \fB(\fR\fIinput,audio\fR\fB)\fR" 4
.IX Item "-request_sample_fmt[:stream_specifier] integer (input,audio)"
sample format audio decoders should prefer
.Sp
Possible values:
.RS 4
.IP "\fBu8\fR" 4
.IX Item "u8"
8\-bit unsigned integer
.IP "\fBs16\fR" 4
.IX Item "s16"
16\-bit signed integer
.IP "\fBs32\fR" 4
.IX Item "s32"
32\-bit signed integer
.IP "\fBflt\fR" 4
.IX Item "flt"
32\-bit float
.IP "\fBdbl\fR" 4
.IX Item "dbl"
64\-bit double
.IP "\fBu8p\fR" 4
.IX Item "u8p"
8\-bit unsigned integer planar
.IP "\fBs16p\fR" 4
.IX Item "s16p"
16\-bit signed integer planar
.IP "\fBs32p\fR" 4
.IX Item "s32p"
32\-bit signed integer planar
.IP "\fBfltp\fR" 4
.IX Item "fltp"
32\-bit float planar
.IP "\fBdblp\fR" 4
.IX Item "dblp"
64\-bit double planar
.RE
.RS 4
.RE
.IP "\fB\-pkt_timebase[:stream_specifier]\fR \fIrational number\fR \fB()\fR" 4
.IX Item "-pkt_timebase[:stream_specifier] rational number ()"
.SS "Format AVOptions"
.IX Subsection "Format AVOptions"
.PD 0
.IP "\fB\-avioflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-avioflags flags (input/output)"
.PD
Possible values:
.RS 4
.IP "\fBdirect\fR" 4
.IX Item "direct"
reduce buffering
.RE
.RS 4
.RE
.IP "\fB\-probesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-probesize integer (input)"
set probing size
.IP "\fB\-packetsize\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-packetsize integer (output)"
set packet size
.IP "\fB\-fflags\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-fflags flags (input/output)"
Possible values:
.RS 4
.IP "\fBignidx\fR" 4
.IX Item "ignidx"
ignore index
.IP "\fBgenpts\fR" 4
.IX Item "genpts"
generate pts
.IP "\fBnofillin\fR" 4
.IX Item "nofillin"
do not fill in missing values that can be exactly calculated
.IP "\fBnoparse\fR" 4
.IX Item "noparse"
disable AVParsers, this needs nofillin too
.IP "\fBigndts\fR" 4
.IX Item "igndts"
ignore dts
.IP "\fBdiscardcorrupt\fR" 4
.IX Item "discardcorrupt"
discard corrupted frames
.IP "\fBsortdts\fR" 4
.IX Item "sortdts"
try to interleave outputted packets by dts
.IP "\fBkeepside\fR" 4
.IX Item "keepside"
dont merge side data
.IP "\fBlatm\fR" 4
.IX Item "latm"
enable \s-1RTP\s0 \s-1MP4A\-LATM\s0 payload
.IP "\fBnobuffer\fR" 4
.IX Item "nobuffer"
reduce the latency introduced by optional buffering
.RE
.RS 4
.RE
.IP "\fB\-analyzeduration\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-analyzeduration integer (input)"
how many microseconds are analyzed to estimate duration
.IP "\fB\-cryptokey\fR \fIhexadecimal string\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-cryptokey hexadecimal string (input)"
decryption key
.IP "\fB\-indexmem\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-indexmem integer (input)"
max memory used for timestamp index (per stream)
.IP "\fB\-rtbufsize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-rtbufsize integer (input)"
max memory used for buffering real-time frames
.IP "\fB\-fdebug\fR \fIflags\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-fdebug flags (input/output)"
print specific debug info
.Sp
Possible values:
.RS 4
.IP "\fBts\fR" 4
.IX Item "ts"
.RE
.RS 4
.RE
.PD 0
.IP "\fB\-max_delay\fR \fIinteger\fR \fB(\fR\fIinput/output\fR\fB)\fR" 4
.IX Item "-max_delay integer (input/output)"
.PD
maximum muxing or demuxing delay in microseconds
.IP "\fB\-fpsprobesize\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-fpsprobesize integer (input)"
number of frames used to probe fps
.IP "\fB\-audio_preload\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-audio_preload integer (output)"
microseconds by which audio packets should be interleaved earlier
.IP "\fB\-chunk_duration\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-chunk_duration integer (output)"
microseconds for each chunk
.IP "\fB\-chunk_size\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-chunk_size integer (output)"
size in bytes for each chunk
.IP "\fB\-f_err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-f_err_detect flags (input)"
set error detection flags (deprecated; use err_detect, save via avconv)
.Sp
Possible values:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
verify embedded CRCs
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
detect bitstream specification deviations
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
detect improper bitstream length
.IP "\fBexplode\fR" 4
.IX Item "explode"
abort decoding on minor error detection
.IP "\fBcareful\fR" 4
.IX Item "careful"
consider things that violate the spec and have not been seen in the wild as errors
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
consider all spec non compliancies as errors
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
consider things that a sane encoder shouldnt do as an error
.RE
.RS 4
.RE
.IP "\fB\-err_detect\fR \fIflags\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-err_detect flags (input)"
set error detection flags
.Sp
Possible values:
.RS 4
.IP "\fBcrccheck\fR" 4
.IX Item "crccheck"
verify embedded CRCs
.IP "\fBbitstream\fR" 4
.IX Item "bitstream"
detect bitstream specification deviations
.IP "\fBbuffer\fR" 4
.IX Item "buffer"
detect improper bitstream length
.IP "\fBexplode\fR" 4
.IX Item "explode"
abort decoding on minor error detection
.IP "\fBcareful\fR" 4
.IX Item "careful"
consider things that violate the spec and have not been seen in the wild as errors
.IP "\fBcompliant\fR" 4
.IX Item "compliant"
consider all spec non compliancies as errors
.IP "\fBaggressive\fR" 4
.IX Item "aggressive"
consider things that a sane encoder shouldnt do as an error
.RE
.RS 4
.RE
.IP "\fB\-use_wallclock_as_timestamps\fR \fIinteger\fR \fB(\fR\fIinput\fR\fB)\fR" 4
.IX Item "-use_wallclock_as_timestamps integer (input)"
use wallclock as timestamps
.IP "\fB\-avoid_negative_ts\fR \fIinteger\fR \fB(\fR\fIoutput\fR\fB)\fR" 4
.IX Item "-avoid_negative_ts integer (output)"
avoid negative timestamps
.SS "Main options"
.IX Subsection "Main options"
.IP "\fB\-f\fR \fIconfigfile\fR" 4
.IX Item "-f configfile"
Use \fIconfigfile\fR instead of \fI/etc/ffserver.conf\fR.
.IP "\fB\-n\fR" 4
.IX Item "-n"
Enable no-launch mode. This option disables all the Launch directives
within the various <Stream> sections. Since ffserver will not launch
any ffmpeg instances, you will have to launch them manually.
.IP "\fB\-d\fR" 4
.IX Item "-d"
Enable debug mode. This option increases log verbosity, directs log
messages to stdout and causes ffserver to run in the foreground
rather than as a daemon.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIffmpeg\fR\|(1), \fIffplay\fR\|(1), \fIffprobe\fR\|(1), the \fIffserver.conf\fR
example and the FFmpeg \s-1HTML\s0 documentation
.SH "AUTHORS"
.IX Header "AUTHORS"
The FFmpeg developers
